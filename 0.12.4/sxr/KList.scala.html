<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>KList.scala</title>
        <script type="text/javascript" src="jquery-all.js"></script>
        <script type="text/javascript" src="linked.js"></script>
        <link rel="stylesheet" type="text/css" href="style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2010 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> <a href="Types.scala.html#12641" title="object sbt.Types">Types</a>._

<span class="comment">/** A higher-order heterogeneous list.  It has a type constructor M[_] and
* type parameters HL.  The underlying data is M applied to each type parameter.
* Explicitly tracking M[_] allows performing natural transformations or ensuring
* all data conforms to some common type.
*
* For background, see
* http://apocalisp.wordpress.com/2010/11/01/type-level-programming-in-scala-part-8a-klist%C2%A0motivation/
 */</span>
<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait KList[+M[_], HL &lt;: sbt.HList] extends java.lang.Object" id="12523">KList</a><span class="delimiter">[</span>+<a title="[_]&gt;: Nothing &lt;: Any" id="12524">M</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028911">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: sbt.HList" id="12525">HL</a> &lt;: HList<span class="delimiter">]</span>
<span title="java.lang.Object" class="delimiter">{</span>
	<span class="keyword">type</span> <a title="HL" id="336925">Raw</a> = <a href="#12525" title="HL">HL</a>
	<span class="comment">/** Transform to the underlying HList type.*/</span>
	<span class="keyword">def</span> <a title="(implicit ev: sbt.~&gt;[M,sbt.Types.Id])HL" id="336926">down</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.~&gt;[M,sbt.Types.Id]" id="2028968">ev</a>: M <a href="TypeFunctions.scala.html#12630" title="sbt.~&gt;[M,sbt.Types.Id]">~&gt;</a> Id<span class="delimiter">)</span>: <a href="#12525" title="HL">HL</a>
	<span class="comment">/** Apply a natural transformation. */</span>
	<span class="keyword">def</span> <a title="[N[_]](f: sbt.~&gt;[M,N])sbt.KList[N,HL]" id="336927">transform</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="336929">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028929">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[M,N]" id="2028928">f</a>: M <a href="TypeFunctions.scala.html#12630" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span>: <a href="#12523" title="sbt.KList[N,HL]">KList</a><span class="delimiter">[</span>N, HL<span class="delimiter">]</span>
	<span class="comment">/** Convert to a List. */</span>
	<span class="keyword">def</span> <a title="=&gt; List[M[_]]" id="336930">toList</a>: <span title="List[M[_]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
	<span class="comment">/** Convert to an HList. */</span>
	<span class="keyword">def</span> <a title="[N[X] &gt;: M[X]]=&gt; HL#Wrap[N]" id="336931">combine</a><span class="delimiter">[</span><a title="[X]&gt;: M[X] &lt;: Any" id="336933">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028892">X</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>: HL#<a href="HList.scala.html#29933" title="HL#Wrap[N]">Wrap</a><span class="delimiter">[</span>N<span class="delimiter">]</span>

	<span class="keyword">def</span> <a title="[P[_ &lt;: sbt.HList], N[X] &gt;: M[X]](f: sbt.KFold[N,P])P[HL]" id="336934">foldr</a><span class="delimiter">[</span><a title="[_ &lt;: sbt.HList]&gt;: Nothing &lt;: Any" id="336937">P</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: sbt.HList" id="2028822">_</a> &lt;: HList<span class="delimiter">]</span>,<a title="[X]&gt;: M[X] &lt;: Any" id="336938">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028823">X</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.KFold[N,P]" id="2028821">f</a>: <a href="#12526" title="sbt.KFold[N,P]">KFold</a><span class="delimiter">[</span>N,P<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#336937" title="P[HL]">P</a><span class="delimiter">[</span>HL<span class="delimiter">]</span>
<span class="delimiter">}</span>
<span class="keyword">trait</span> <a title="trait KFold[M[_], P[_ &lt;: sbt.HList]] extends java.lang.Object" id="12526">KFold</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="12527">M</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2151921">_</a><span class="delimiter">]</span>,<a title="[_ &lt;: sbt.HList]&gt;: Nothing &lt;: Any" id="12528">P</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: sbt.HList" id="2028853">_</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">]</span>
<span title="java.lang.Object" class="delimiter">{</span>
	<span class="keyword">def</span> <a title="[H, T &lt;: sbt.HList](h: M[H], acc: P[T])P[sbt.Types.:+:[H,T]]" id="2028845">kcons</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028848">H</a>,<a title="&gt;: Nothing &lt;: sbt.HList" id="2028849">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="M[H]" id="2028851">h</a>: <a href="#12527" title="M[H]">M</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a title="P[T]" id="2028852">acc</a>: <a href="#12528" title="P[T]">P</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12528" title="P[sbt.Types.:+:[H,T]]">P</a><span class="delimiter">[</span>H :+: T<span class="delimiter">]</span>
	<span class="keyword">def</span> <a title="=&gt; P[sbt.HNil]" id="2028850">knil</a>: <a href="#12528" title="P[sbt.HNil]">P</a><span class="delimiter">[</span>HNil<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="keyword">final</span> case <span class="keyword">class</span> <a title="class KCons[H, T &lt;: sbt.HList, +M[_]] extends java.lang.Object with sbt.KList[M,sbt.Types.:+:[H,T]] with ScalaObject with Product with Serializable" id="2152437">KCons</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="336969">H</a>, <a title="&gt;: Nothing &lt;: sbt.HList" id="336970">T</a> &lt;: HList, +<a title="[_]&gt;: Nothing &lt;: Any" id="336971">M</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="337014">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#2152437" title="ScalaObject" class="delimiter">(</a><a title="M[H]" id="337012">head</a>: <a href="#336971" title="M[H]">M</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a title="sbt.KList[M,T]" id="337013">tail</a>: <a href="#12523" title="sbt.KList[M,T]">KList</a><span class="delimiter">[</span>M,T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#12523" title="sbt.KList[M,sbt.Types.:+:[H,T]]">KList</a><span class="delimiter">[</span>M, H :+: T<span class="delimiter">]</span>
<span class="delimiter">{</span>
	<span class="keyword">def</span> <a title="(implicit f: sbt.~&gt;[M,sbt.Types.Id])sbt.HCons[sbt.Types.Id[H],T]" id="336979">down</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.~&gt;[M,sbt.Types.Id]" id="2028970">f</a>: M <a href="TypeFunctions.scala.html#12630" title="sbt.~&gt;[M,sbt.Types.Id]">~&gt;</a> Id<span class="delimiter">)</span> = <a href="HList.scala.html#30065" title="(head: sbt.Types.Id[H], tail: T)sbt.HCons[sbt.Types.Id[H],T]">HCons</a><span class="delimiter">(</span><a href="TypeFunctions.scala.html#328767" title="(a: M[H])sbt.Types.Id[H]">f</a><span class="delimiter">(</span><a href="#337012" title="=&gt; M[H]">head</a><span class="delimiter">)</span>, <a href="#337013" title="=&gt; sbt.KList[M,T]">tail</a> <a href="#336926" title="(implicit ev: sbt.~&gt;[M,sbt.Types.Id])T">down</a> <a href="#2028970" title="sbt.~&gt;[M,sbt.Types.Id]">f</a><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[N[_]](f: sbt.~&gt;[M,N])sbt.KCons[H,T,N]" id="336980">transform</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="336982">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028935">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[M,N]" id="2028932">f</a>: M <a href="TypeFunctions.scala.html#12630" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <a href="#2152437" title="(head: N[H], tail: sbt.KList[N,T])sbt.KCons[H,T,N]">KCons</a><span class="delimiter">(</span> <a href="TypeFunctions.scala.html#328767" title="(a: M[H])N[H]">f</a><span class="delimiter">(</span><a href="#337012" title="=&gt; M[H]">head</a><span class="delimiter">)</span>, <a href="#337013" title="=&gt; sbt.KList[M,T]">tail</a> <a href="#336927" title="(f: sbt.~&gt;[M,N])sbt.KList[N,T]">transform</a> <a href="#2028932" title="sbt.~&gt;[M,N]">f</a> <span class="delimiter">)</span>
	<span class="comment">// prepend</span>
	<span class="keyword">def</span> <a title="[N[X] &gt;: M[X], G](g: N[G])sbt.KCons[G,sbt.Types.:+:[H,T],N]" id="336983">:^:</a> <span class="delimiter">[</span><a title="[X]&gt;: M[X] &lt;: Any" id="336986">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="337043">X</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>X<span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="336987">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="N[G]" id="337033">g</a>: <a href="#336986" title="N[G]">N</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#2152437" title="(head: N[G], tail: sbt.KList[N,sbt.Types.:+:[H,T]])sbt.KCons[G,sbt.Types.:+:[H,T],N]">KCons</a><span class="delimiter">(</span><a href="#337033" title="N[G]">g</a>, <a href="#2152437" title="sbt.KCons[H,T,M]" class="keyword">this</a><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="=&gt; List[M[_]]" id="336988">toList</a> = <a href="#337012" title="=&gt; M[H]">head</a> <a href="#2028916" title="(x: M[_])List[M[_]]">::</a> <a href="#337013" title="=&gt; sbt.KList[M,T]">tail</a>.<a href="#336930" title="=&gt; List[M[_]]">toList</a>
	
	<span class="keyword">def</span> <a title="[N[X] &gt;: M[X]]=&gt; sbt.HCons[N[H],T#Wrap[N]]" id="336989">combine</a><span class="delimiter">[</span><a title="[X]&gt;: M[X] &lt;: Any" id="336991">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028900">X</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span>: <span class="delimiter">(</span>H :+: T<span class="delimiter">)</span>#Wrap<span class="delimiter">[</span>N<span class="delimiter">]</span> = <a href="HList.scala.html#30065" title="(head: N[H], tail: T#Wrap[N])sbt.HCons[N[H],T#Wrap[N]]">HCons</a><span class="delimiter">(</span><a href="#337012" title="=&gt; M[H]">head</a>, <a href="#337013" title="=&gt; sbt.KList[M,T]">tail</a>.<a href="#336931" title="T#Wrap[N]">combine</a><span class="delimiter">)</span>

	<span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="336992">toString</a> = <a href="#337012" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">head</a> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot; :^: &quot;)" class="string">&quot; :^: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#337013" title="=&gt; sbt.KList[M,T]">tail</a>.<span title="()java.lang.String">toString</span>

	<span class="keyword">def</span> <a title="[P[_ &lt;: sbt.HList], N[X] &gt;: M[X]](f: sbt.KFold[N,P])P[sbt.Types.:+:[H,T]]" id="336993">foldr</a><span class="delimiter">[</span><a title="[_ &lt;: sbt.HList]&gt;: Nothing &lt;: Any" id="336996">P</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: sbt.HList" id="2028838">_</a> &lt;: HList<span class="delimiter">]</span>,<a title="[X]&gt;: M[X] &lt;: Any" id="336997">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2028837">X</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.KFold[N,P]" id="2028830">f</a>: <a href="#12526" title="sbt.KFold[N,P]">KFold</a><span class="delimiter">[</span>N,P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#2028830" title="sbt.KFold[N,P]">f</a>.<a href="#2028845" title="(h: N[H], acc: P[T])P[sbt.Types.:+:[H,T]]">kcons</a><span class="delimiter">(</span><a href="#337012" title="=&gt; M[H]">head</a>, <a href="#337013" title="=&gt; sbt.KList[M,T]">tail</a> <a href="#336934" title="(f: sbt.KFold[N,P])P[T]">foldr</a> <a href="#2028830" title="sbt.KFold[N,P]">f</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">sealed</span> <span class="keyword">class</span> <a title="class KNil extends java.lang.Object with sbt.KList[Nothing,sbt.HNil] with ScalaObject" id="12535">KNil</a> <a href="#12535" title="ScalaObject" class="keyword">extends</a> <a href="#12523" title="sbt.KList[Nothing,sbt.HNil]">KList</a><span class="delimiter">[</span>Nothing, HNil<span class="delimiter">]</span>
<span class="delimiter">{</span>
	<span class="keyword">def</span> <a title="(implicit f: sbt.~&gt;[Nothing,sbt.Types.Id])sbt.HNil.type" id="336940">down</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.~&gt;[Nothing,sbt.Types.Id]" id="2151995">f</a>: Nothing <a href="TypeFunctions.scala.html#12630" title="sbt.~&gt;[Nothing,sbt.Types.Id]">~&gt;</a> Id<span class="delimiter">)</span> = <a href="HList.scala.html#12492" title="object sbt.HNil">HNil</a>
	<span class="keyword">def</span> <a title="[N[_]](f: sbt.~&gt;[Nothing,N])sbt.KNil.type" id="336941">transform</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="336943">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2152002">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[Nothing,N]" id="2151999">f</a>: Nothing <a href="TypeFunctions.scala.html#12630" title="sbt.~&gt;[Nothing,N]">~&gt;</a> N<span class="delimiter">)</span> = <a href="#12536" title="object sbt.KNil">KNil</a>
	<span class="keyword">def</span> <a title="[M[_], H](h: M[H])sbt.KCons[H,sbt.HNil,M]" id="336944">:^:</a> <span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="336947">M</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="337024">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="336948">H</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[H]" id="336960">h</a>: <a href="#336947" title="M[H]">M</a><span class="delimiter">[</span>H<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#2152437" title="(head: M[H], tail: sbt.KList[M,sbt.HNil])sbt.KCons[H,sbt.HNil,M]">KCons</a><span class="delimiter">(</span><a href="#336960" title="M[H]">h</a>, <a href="#12535" title="sbt.KNil" class="keyword">this</a><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="336949">toList</a> = <span title="object Nil">Nil</span>
	<span class="keyword">def</span> <a title="[N[X]]=&gt; sbt.HNil.type" id="336950">combine</a><span class="delimiter">[</span><a title="[X]&gt;: Nothing &lt;: Any" id="336952">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2152017">X</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="HList.scala.html#12492" title="object sbt.HNil">HNil</a>
	<span class="keyword">override</span> <span class="keyword">def</span> <a title="[P[_ &lt;: sbt.HList], N[_]](f: sbt.KFold[N,P])P[sbt.HNil]" id="336953">foldr</a><span class="delimiter">[</span><a title="[_ &lt;: sbt.HList]&gt;: Nothing &lt;: Any" id="336956">P</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: sbt.HList" id="2152028">_</a> &lt;: HList<span class="delimiter">]</span>,<a title="[_]&gt;: Nothing &lt;: Any" id="336957">N</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2152027">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.KFold[N,P]" id="2152020">f</a>: <a href="#12526" title="sbt.KFold[N,P]">KFold</a><span class="delimiter">[</span>N,P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#2152020" title="sbt.KFold[N,P]">f</a>.<a href="#2028850" title="=&gt; P[sbt.HNil]">knil</a>
	<span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="336958">toString</a> = <span title="java.lang.String(&quot;KNil&quot;)" class="string">&quot;KNil&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">object</span> <a title="object sbt.KNil" id="12536">KNil</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#12535" title="sbt.KNil">KNil</a>

<span class="keyword">object</span> <a title="object sbt.KList" id="12538">KList</a>
<span title="ScalaObject" class="delimiter">{</span>
	<span class="comment">// nicer alias for pattern matching</span>
	<span class="keyword">val</span> <a title="sbt.KCons.type" id="401636">:^:</a> = <a href="#2152437" title="object sbt.KCons">KCons</a>
	
	<span class="keyword">def</span> <a title="[M[_]](s: Seq[M[_]])sbt.KList[M, _ &lt;: sbt.HList]" id="401638">fromList</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="401640">M</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="2130380">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[M[_]]" id="2130378">s</a>: <span title="Seq[M[_]]">Seq</span><span class="delimiter">[</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12523" title="sbt.KList[M, _ &lt;: sbt.HList]">KList</a><span class="delimiter">[</span>M, _ &lt;: HList<span class="delimiter">]</span> = <span title="&lt;none&gt; extends ScalaObject with sbt.KList[M, _ &gt;: sbt.HNil with sbt.Types.:+:[_$2,_$3] &lt;: ScalaObject with sbt.HList]" class="keyword">if</span><span class="delimiter">(</span><a href="#2130378" title="Seq[M[_]]">s</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#12536" title="object sbt.KNil">KNil</a> <span class="keyword">else</span> <a href="#2152437" title="(head: M[_$2], tail: sbt.KList[M,_$3])sbt.KCons[_$2,_$3,M]">KCons</a><span class="delimiter">(</span><a href="#2130378" title="Seq[M[_]]">s</a>.<span title="=&gt; M[_]">head</span>, <a href="#401638" title="(s: Seq[M[_]])sbt.KList[M, _ &lt;: sbt.HList]">fromList</a><span class="delimiter">(</span><a href="#2130378" title="Seq[M[_]]">s</a>.<span title="=&gt; Seq[M[_]]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span>

	<span class="comment">// haven't found a way to convince scalac that KList[M, H :+: T] implies KCons[H,T,M]</span>
	<span class="comment">// Therefore, this method exists to put the cast in one location.</span>
	<span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[H, T &lt;: sbt.HList, M[_]](kl: sbt.KList[M,sbt.Types.:+:[H,T]])sbt.KCons[H,T,M]" id="401641">kcons</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="401645">H</a>, <a title="&gt;: Nothing &lt;: sbt.HList" id="401646">T</a> &lt;: HList, <a title="[_]&gt;: Nothing &lt;: Any" id="401647">M</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="401662">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.KList[M,sbt.Types.:+:[H,T]]" id="401661">kl</a>: <a href="#12523" title="sbt.KList[M,sbt.Types.:+:[H,T]]">KList</a><span class="delimiter">[</span>M, H :+: T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#2152437" title="sbt.KCons[H,T,M]">KCons</a><span class="delimiter">[</span>H,T,M<span class="delimiter">]</span> =
		<a href="#401661" title="sbt.KList[M,sbt.Types.:+:[H,T]]">kl</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="sbt.KCons[H,T,M]" class="delimiter">[</span><a href="#2152437" title="sbt.KCons[H,T,M]">KCons</a><span class="delimiter">[</span>H,T,M<span class="delimiter">]</span><span class="delimiter">]</span>
	<span class="comment">// haven't need this, but for symmetry with kcons:</span>
	<span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M[_]](kl: sbt.KList[M,sbt.HNil])sbt.KNil" id="401648">knil</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="401650">M</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="401658">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.KList[M,sbt.HNil]" id="401656">kl</a>: <a href="#12523" title="sbt.KList[M,sbt.HNil]">KList</a><span class="delimiter">[</span>M, HNil<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12535" title="sbt.KNil">KNil</a> = <a href="#12536" title="object sbt.KNil">KNil</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>