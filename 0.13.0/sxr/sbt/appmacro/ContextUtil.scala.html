<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/appmacro/ContextUtil.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> appmacro

	<span class="keyword">import</span> scala.reflect._
	<span class="keyword">import</span> macros._
	<span class="keyword">import</span> scala.tools.nsc.Global
	<span class="keyword">import</span> <a href="#sbt.appmacro.ContextUtil" title="sbt.appmacro.ContextUtil.type">ContextUtil</a>.<span class="delimiter">{</span>DynamicDependencyError, DynamicReferenceError<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="sbt.appmacro.ContextUtil.type" id="sbt.appmacro.ContextUtil">ContextUtil</a> <a href="#sbt.appmacro.ContextUtil" title="sbt.appmacro.ContextUtil.type" class="delimiter">{</a>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;Illegal dynamic dependency&quot;)" id="sbt.appmacro.ContextUtil.DynamicDependencyError">DynamicDependencyError</a> = <span title="String(&quot;Illegal dynamic dependency&quot;)" class="string">&quot;Illegal dynamic dependency&quot;</span>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;Illegal dynamic reference&quot;)" id="sbt.appmacro.ContextUtil.DynamicReferenceError">DynamicReferenceError</a> = <span title="String(&quot;Illegal dynamic reference&quot;)" class="string">&quot;Illegal dynamic reference&quot;</span>

	<span class="comment">/** Constructs an object with utility methods for operating in the provided macro context `c`.
	* Callers should explicitly specify the type parameter as `c.type` in order to preserve the path dependent types. */</span>
	<span class="keyword">def</span> <a title="[C &lt;: scala.reflect.macros.Context with Singleton](c: C)sbt.appmacro.ContextUtil[C]" id="sbt.appmacro.ContextUtil.apply">apply</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context with Singleton" id="sbt.appmacro.ContextUtil.apply;C">C</a> &lt;: Context <span class="keyword">with</span> Singleton<span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="sbt.appmacro.ContextUtil.apply.c">c</a>: <a href="#sbt.appmacro.ContextUtil.apply;C" title="C">C</a><span class="delimiter">)</span>: <a href="#sbt.appmacro;ContextUtil" title="sbt.appmacro.ContextUtil[C]">ContextUtil</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <span title="sbt.appmacro.ContextUtil[C]" class="keyword">new</span> <a href="#sbt.appmacro;ContextUtil" title="sbt.appmacro.ContextUtil[C]">ContextUtil</a><span class="delimiter">(</span><a href="#sbt.appmacro.ContextUtil.apply.c" title="C">c</a><span class="delimiter">)</span>


	<span class="comment">/** Helper for implementing a no-argument macro that is introduced via an implicit.
	* This method removes the implicit conversion and evaluates the function `f` on the target of the conversion.
	*
	* Given `myImplicitConversion(someValue).extensionMethod`, where `extensionMethod` is a macro that uses this
	* method, the result of this method is `f(&lt;Tree of someValue&gt;)`. */</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(f: (c.Expr[Any], c.Position) =&gt; c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" id="sbt.appmacro.ContextUtil.selectMacroImpl">selectMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.ContextUtil.selectMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.appmacro.ContextUtil.selectMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(c.Expr[Any], c.Position) =&gt; c.Expr[T]" id="sbt.appmacro.ContextUtil.selectMacroImpl.f">f</a>: <span class="delimiter">(</span>c.Expr<span class="delimiter">[</span>Any<span class="delimiter">]</span>, c.Position<span class="delimiter">)</span> =&gt; c.Expr<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
		<a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Tree">macroApplication</span> <span title="c.Expr[T]" class="keyword">match</span> <span class="delimiter">{</span>
			<span class="keyword">case</span> <a title="c.universe.Select" id="sbt.appmacro.ContextUtil.selectMacroImpl.s">s</a> @ <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(select: c.universe.Select)Option[(c.universe.Tree, c.universe.Name)]">Select</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(x: Any)Option[c.universe.Select]" class="delimiter">(</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(apply: c.universe.Apply)Option[(c.universe.Tree, List[c.universe.Tree])]">Apply</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(x: Any)Option[c.universe.Apply]" class="delimiter">(</a>_, <a title="c.universe.Tree" id="sbt.appmacro.ContextUtil.selectMacroImpl.t">t</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="c.universe.Name" id="sbt.appmacro.ContextUtil.selectMacroImpl.tp">tp</a><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.f" title="(v1: c.Expr[Any], v2: c.Position)c.Expr[T]">f</a><span class="delimiter">(</span> <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[Any])c.Expr[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[Any]" class="delimiter">(</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.t" title="c.universe.Tree">t</a><span class="delimiter">)</span>, <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.s" title="c.universe.Select">s</a>.<span title="=&gt; c.universe.Position">pos</span> <span class="delimiter">)</span>
			<span class="keyword">case</span> <a title="c.Tree" id="sbt.appmacro.ContextUtil.selectMacroImpl.x">x</a> =&gt; <a href="#sbt.appmacro.ContextUtil.unexpectedTree" title="(tree: _449.universe.Tree forSome { val _449: scala.reflect.macros.Context })Nothing">unexpectedTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.x" title="c.Tree">x</a><span class="delimiter">)</span>
		<span class="delimiter">}</span>
	<span class="delimiter">}</span>

	<span class="keyword">def</span> <a title="[C &lt;: scala.reflect.macros.Context](tree: _449.universe.Tree forSome { val _449: C })Nothing" id="sbt.appmacro.ContextUtil.unexpectedTree">unexpectedTree</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context" id="sbt.appmacro.ContextUtil.unexpectedTree;C">C</a> &lt;: Context<span class="delimiter">]</span><span class="delimiter">(</span><a title="_449.universe.Tree forSome { val _449: C }" id="sbt.appmacro.ContextUtil.unexpectedTree.tree">tree</a>: C#<span title="_1145.universe.Tree forSome { val _1145: C }">Tree</span><span class="delimiter">)</span>: <span title="Nothing">Nothing</span> = sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Unexpected macro application tree (&quot;)" class="string">&quot;Unexpected macro application tree (&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro.ContextUtil.unexpectedTree.tree" title="_449.universe.Tree forSome { val _449: C }">tree</a>.<span title="()Class[_]">getClass</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;): &quot;)" class="string">&quot;): &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro.ContextUtil.unexpectedTree.tree" title="_449.universe.Tree forSome { val _449: C }">tree</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/** Utility methods for macros.  Several methods assume that the context's universe is a full compiler (`scala.tools.nsc.Global`).
* This is not thread safe due to the underlying Context and related data structures not being thread safe.
* Use `ContextUtil[c.type](c)` to construct. */</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a title="class ContextUtil[C &lt;: scala.reflect.macros.Context] extends AnyRef" id="sbt.appmacro;ContextUtil">ContextUtil</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context" id="sbt.appmacro;ContextUtil;C">C</a> &lt;: Context<span class="delimiter">]</span><a href="#sbt.appmacro;ContextUtil" title="sbt.appmacro.ContextUtil[C]" class="delimiter">(</a><span class="keyword">val</span> <a title="C" id="sbt.appmacro;ContextUtil.ctx">ctx</a>: <a href="#sbt.appmacro;ContextUtil;C" title="C">C</a><span class="delimiter">)</span> 
<span class="delimiter">{</span>
		<span class="keyword">import</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span class="delimiter">{</span>Apply=&gt;ApplyTree,_<span class="delimiter">}</span>

	<span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.Type" id="sbt.appmacro;ContextUtil.alistType">alistType</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="[T](implicit ttag: ContextUtil.this.ctx.TypeTag[T])ContextUtil.this.ctx.Type">typeOf</span><a href="#sbt.appmacro;ContextUtil.ctx" title="(implicit ttag: ContextUtil.this.ctx.TypeTag[sbt.AList[sbt.KList]])ContextUtil.this.ctx.Type" class="delimiter">[</a><a href="../AList.scala.html#sbt;AList" title="sbt.AList[sbt.KList]">AList</a><span class="delimiter">[</span>KList<span class="delimiter">]</span><span class="delimiter">]</span>
	<span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.alist">alist</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> = <a href="#sbt.appmacro;ContextUtil.alistType" title="=&gt; ContextUtil.this.ctx.Type">alistType</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">typeSymbol</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">companionSymbol</span>
	<span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.alistTC">alistTC</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> = <a href="#sbt.appmacro;ContextUtil.alistType" title="=&gt; ContextUtil.this.ctx.Type">alistType</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">typeConstructor</span>

	<span class="comment">/** Modifiers for a local val.*/</span>
	<span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Modifiers" id="sbt.appmacro;ContextUtil.localModifiers">localModifiers</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(flags: ContextUtil.this.ctx.universe.FlagSet)ContextUtil.this.ctx.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.FlagSet">NoFlags</a><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="(sym: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.Position" id="sbt.appmacro;ContextUtil.getPos">getPos</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.getPos.sym">sym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span> = <span title="ContextUtil.this.ctx.universe.Position" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.getPos.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Position">NoPosition</a> <span class="keyword">else</span> <a href="#sbt.appmacro;ContextUtil.getPos.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Position">pos</span>

	<span class="comment">/** Constructs a unique term name with the given prefix within this Context.
	* (The current implementation uses Context.fresh, which increments*/</span>
	<span class="keyword">def</span> <a title="(prefix: String)ContextUtil.this.ctx.universe.TermName" id="sbt.appmacro;ContextUtil.freshTermName">freshTermName</a><span class="delimiter">(</span><a title="String" id="sbt.appmacro;ContextUtil.freshTermName.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(s: String)ContextUtil.this.ctx.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(name: String)String">fresh</span><span class="delimiter">(</span><span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.freshTermName.prefix" title="String">prefix</a><span class="delimiter">)</span><span class="delimiter">)</span>

	<span class="comment">/** Constructs a new, local ValDef with the given Type, a unique name, 
	* the same position as `sym`, and an empty implementation (no rhs). */</span>
	<span class="keyword">def</span> <a title="(tpe: ContextUtil.this.ctx.universe.Type, sym: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.freshValDef">freshValDef</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.freshValDef.tpe">tpe</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.freshValDef.sym">sym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.freshValDef.vd">vd</a> = <a href="#sbt.appmacro;ContextUtil.localValDef" title="(tpt: ContextUtil.this.ctx.universe.Tree, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef">localValDef</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="(tp: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshValDef.tpe" title="ContextUtil.this.ctx.universe.Type">tpe</a><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Tree">EmptyTree</a><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.freshValDef.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a> <span title="(newpos: ContextUtil.this.ctx.universe.Position)ContextUtil.this.ctx.universe.Tree">setPos</span> <a href="#sbt.appmacro;ContextUtil.getPos" title="(sym: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.Position">getPos</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshValDef.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.freshValDef.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>
	<span class="delimiter">}</span>

	<span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Modifiers" id="sbt.appmacro;ContextUtil.parameterModifiers">parameterModifiers</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(flags: ContextUtil.this.ctx.universe.FlagSet)ContextUtil.this.ctx.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.FlagValues">Flag</a>.<span title="=&gt; ContextUtil.this.ctx.universe.FlagSet">PARAM</span><span class="delimiter">)</span>

	<span class="comment">/** Collects all definitions in the tree for use in checkReferences.
	* This excludes definitions in wrapped expressions because checkReferences won't allow nested dereferencing anyway. */</span>
	<span class="keyword">def</span> <a title="(tree: ContextUtil.this.ctx.universe.Tree, isWrapper: (String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean)scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.collectDefs">collectDefs</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.tree">tree</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="(String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean" id="sbt.appmacro;ContextUtil.collectDefs.isWrapper">isWrapper</a>: <span class="delimiter">(</span>String, Type, Tree<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: collection.<span title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = 
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.collectDefs.defs">defs</a> = <span title="()scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]" class="keyword">new</span> collection.mutable.<span title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]">HashSet</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
		<span class="comment">// adds the symbols for all non-Ident subtrees to `defs`.</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Traverser" id="sbt.appmacro;ContextUtil.collectDefs.process">process</a> = <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon" title="ContextUtil.this.ctx.universe.Traverser" class="keyword">new</a> <a href="#sbt.appmacro;ContextUtil.ctx" title="anonymous class $anon extends ContextUtil.this.ctx.universe.Traverser" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon">Traverser</a> <span class="delimiter">{</span>
			<span class="keyword">override</span> <span class="keyword">def</span> <a title="(t: ContextUtil.this.ctx.universe.Tree)Unit" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse">traverse</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.t">t</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">)</span> = <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.t" title="ContextUtil.this.ctx.universe.Tree">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
				<span class="keyword">case</span> _: <a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Ident]">Ident</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
				<span class="keyword">case</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="(apply: ContextUtil.this.ctx.universe.Apply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">ApplyTree</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Apply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeApply: ContextUtil.this.ctx.universe.TypeApply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">TypeApply</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.TypeApply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(select: ContextUtil.this.ctx.universe.Select)Option[(ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Name)]">Select</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Select]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.nme">nme</a><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tpe">tpe</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.qual">qual</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.appmacro;ContextUtil.collectDefs.isWrapper" title="(v1: String, v2: ContextUtil.this.ctx.universe.Type, v3: ContextUtil.this.ctx.universe.Tree)Boolean">isWrapper</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.nme" title="ContextUtil.this.ctx.universe.Name">nme</a>.<span title="=&gt; String">decoded</span>, <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tpe" title="ContextUtil.this.ctx.universe.Tree">tpe</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>, <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.qual" title="ContextUtil.this.ctx.universe.Tree">qual</a><span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
				<span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree">tree</a> =&gt;
					<span title="Any" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">symbol</span> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#sbt.appmacro;ContextUtil.collectDefs.defs" title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]">defs</a> <span title="(elem: ContextUtil.this.ctx.universe.Symbol)defs.type">+=</span> <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">symbol</span>;
					<a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon" title="ContextUtil.this.ctx.universe.Traverser" class="keyword">super</a>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
			<span class="delimiter">}</span>
		<span class="delimiter">}</span>
		<a href="#sbt.appmacro;ContextUtil.collectDefs.process" title="ContextUtil.this.ctx.universe.Traverser">process</a>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.collectDefs.defs" title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]">defs</a>
	<span class="delimiter">}</span>

	<span class="comment">/** A reference is illegal if it is to an M instance defined within the scope of the macro call.
	* As an approximation, disallow referenced to any local definitions `defs`. */</span>
	<span class="keyword">def</span> <a title="(defs: scala.collection.Set[ContextUtil.this.ctx.universe.Symbol], sym: ContextUtil.this.ctx.universe.Symbol)Boolean" id="sbt.appmacro;ContextUtil.illegalReference">illegalReference</a><span class="delimiter">(</span><a title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.illegalReference.defs">defs</a>: collection.<span title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.illegalReference.sym">sym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
		<a href="#sbt.appmacro;ContextUtil.illegalReference.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.illegalReference.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Symbol">NoSymbol</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.illegalReference.defs" title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">defs</a>.<span title="(elem: ContextUtil.this.ctx.universe.Symbol)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.illegalReference.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a><span class="delimiter">)</span>

	<span class="comment">/** A function that checks the provided tree for illegal references to M instances defined in the
	*  expression passed to the macro and for illegal dereferencing of M instances. */</span>
	<span class="keyword">def</span> <a title="(defs: scala.collection.Set[ContextUtil.this.ctx.universe.Symbol], isWrapper: (String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean)ContextUtil.this.ctx.universe.Tree =&gt; Unit" id="sbt.appmacro;ContextUtil.checkReferences">checkReferences</a><span class="delimiter">(</span><a title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.checkReferences.defs">defs</a>: collection.<span title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="(String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean" id="sbt.appmacro;ContextUtil.checkReferences.isWrapper">isWrapper</a>: <span class="delimiter">(</span>String, Type, Tree<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: Tree =&gt; Unit = <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.x0$1" title="Unit" class="delimiter">{</a>
		<span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Apply" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.s">s</a> @ <a href="#sbt.appmacro;ContextUtil.ctx" title="(apply: ContextUtil.this.ctx.universe.Apply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">ApplyTree</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Apply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeApply: ContextUtil.this.ctx.universe.TypeApply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">TypeApply</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.TypeApply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(select: ContextUtil.this.ctx.universe.Select)Option[(ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Name)]">Select</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Select]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.nme">nme</a><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.tpe">tpe</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.qual">qual</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt;
			<span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.isWrapper" title="(v1: String, v2: ContextUtil.this.ctx.universe.Type, v3: ContextUtil.this.ctx.universe.Tree)Boolean">isWrapper</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.nme" title="ContextUtil.this.ctx.universe.Name">nme</a>.<span title="=&gt; String">decoded</span>, <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.tpe" title="ContextUtil.this.ctx.universe.Tree">tpe</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>, <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.qual" title="ContextUtil.this.ctx.universe.Tree">qual</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(pos: ContextUtil.this.ctx.Position, msg: String)Unit">error</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.s" title="ContextUtil.this.ctx.universe.Apply">s</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Position">pos</span>, <span title="String(&quot;Illegal dynamic dependency&quot;)">DynamicDependencyError</span><span class="delimiter">)</span>
		<span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Ident" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.id">id</a> @ <a href="#sbt.appmacro;ContextUtil.ctx" title="(ident: ContextUtil.this.ctx.universe.Ident)Option[ContextUtil.this.ctx.universe.Name]">Ident</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Ident]" class="delimiter">(</a><a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.name">name</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.appmacro;ContextUtil.illegalReference" title="(defs: scala.collection.Set[ContextUtil.this.ctx.universe.Symbol], sym: ContextUtil.this.ctx.universe.Symbol)Boolean">illegalReference</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.defs" title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">defs</a>, <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.id" title="ContextUtil.this.ctx.universe.Ident">id</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">symbol</span><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(pos: ContextUtil.this.ctx.Position, msg: String)Unit">error</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.id" title="ContextUtil.this.ctx.universe.Ident">id</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Position">pos</span>, DynamicReferenceError <span title="String(&quot;Illegal dynamic reference: &quot;)">+</span> <span class="string">&quot;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.name" title="ContextUtil.this.ctx.universe.Name">name</a><span class="delimiter">)</span>
		<span class="keyword">case</span> _ =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>

	<span class="comment">/** Constructs a ValDef with a parameter modifier, a unique name, with the provided Type and with an empty rhs. */</span>
	<span class="keyword">def</span> <a title="(tpe: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.freshMethodParameter">freshMethodParameter</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.freshMethodParameter.tpe">tpe</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span> =
		<a href="#sbt.appmacro;ContextUtil.ctx" title="(mods: ContextUtil.this.ctx.universe.Modifiers, name: ContextUtil.this.ctx.universe.TermName, tpt: ContextUtil.this.ctx.universe.Tree, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.parameterModifiers" title="=&gt; ContextUtil.this.ctx.universe.Modifiers">parameterModifiers</a>, <a href="#sbt.appmacro;ContextUtil.freshTermName" title="(prefix: String)ContextUtil.this.ctx.universe.TermName">freshTermName</a><span class="delimiter">(</span><span title="String(&quot;p&quot;)" class="string">&quot;p&quot;</span><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.ctx" title="(tp: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshMethodParameter.tpe" title="ContextUtil.this.ctx.universe.Type">tpe</a><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Tree">EmptyTree</a><span class="delimiter">)</span>

	<span class="comment">/** Constructs a ValDef with local modifiers and a unique name. */</span>
	<span class="keyword">def</span> <a title="(tpt: ContextUtil.this.ctx.universe.Tree, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.localValDef">localValDef</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.localValDef.tpt">tpt</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.localValDef.rhs">rhs</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span> =
		<a href="#sbt.appmacro;ContextUtil.ctx" title="(mods: ContextUtil.this.ctx.universe.Modifiers, name: ContextUtil.this.ctx.universe.TermName, tpt: ContextUtil.this.ctx.universe.Tree, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.localModifiers" title="=&gt; ContextUtil.this.ctx.universe.Modifiers">localModifiers</a>, <a href="#sbt.appmacro;ContextUtil.freshTermName" title="(prefix: String)ContextUtil.this.ctx.universe.TermName">freshTermName</a><span class="delimiter">(</span><span title="String(&quot;q&quot;)" class="string">&quot;q&quot;</span><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.localValDef.tpt" title="ContextUtil.this.ctx.universe.Tree">tpt</a>, <a href="#sbt.appmacro;ContextUtil.localValDef.rhs" title="ContextUtil.this.ctx.universe.Tree">rhs</a><span class="delimiter">)</span>

	<span class="comment">/** Constructs a tuple value of the right TupleN type from the provided inputs.*/</span>
	<span class="keyword">def</span> <a title="(args: List[ContextUtil.this.ctx.universe.Tree])ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.mkTuple">mkTuple</a><span class="delimiter">(</span><a title="List[ContextUtil.this.ctx.universe.Tree]" id="sbt.appmacro;ContextUtil.mkTuple.args">args</a>: <span title="List[ContextUtil.this.ctx.universe.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="scala.tools.nsc.Global" id="sbt.appmacro;ContextUtil.mkTuple.global">global</a>: <span title="scala.tools.nsc.Global">Global</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.tools.nsc.Global" class="delimiter">[</span><span title="scala.tools.nsc.Global">Global</span><span class="delimiter">]</span>
		<a href="#sbt.appmacro;ContextUtil.mkTuple.global" title="scala.tools.nsc.Global">global</a>.<span title="global.gen.type">gen</span>.<span title="(elems: List[global.gen.global.Tree])global.gen.global.Tree">mkTuple</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.mkTuple.args" title="List[ContextUtil.this.ctx.universe.Tree]">args</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[global.Tree]" class="delimiter">[</span><span title="List[global.Tree]">List</span><span class="delimiter">[</span>global.Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Tree" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">]</span>
	<span class="delimiter">}</span>

	<span class="comment">/** Creates a new, synthetic type variable with the specified `owner`. */</span>
	<span class="keyword">def</span> <a title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTypeVariable">newTypeVariable</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.newTypeVariable.owner">owner</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span>, <a title="String" id="sbt.appmacro;ContextUtil.newTypeVariable$default$2">prefix</a>: <span title="String">String</span> = <span title="String(&quot;T0&quot;)" class="string">&quot;T0&quot;</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="scala.tools.nsc.Global" id="sbt.appmacro;ContextUtil.newTypeVariable.global">global</a>: <span title="scala.tools.nsc.Global">Global</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.tools.nsc.Global" class="delimiter">[</span><span title="scala.tools.nsc.Global">Global</span><span class="delimiter">]</span>
		<a href="#sbt.appmacro;ContextUtil.newTypeVariable.owner" title="ContextUtil.this.ctx.universe.Symbol">owner</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="global.Symbol" class="delimiter">[</span>global.<span title="global.Symbol">Symbol</span><span class="delimiter">]</span>.<span title="(name: String, newFlags: Long)global.TypeSymbol">newSyntheticTypeParam</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTypeVariable$default$2" title="String">prefix</a>, <span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.TypeSymbol" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span><span class="delimiter">]</span>
	<span class="delimiter">}</span>
	<span class="comment">/** The type representing the type constructor `[X] X` */</span>
	<span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.idTC">idTC</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.idTC.tvar">tvar</a> = <a href="#sbt.appmacro;ContextUtil.newTypeVariable" title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol">newTypeVariable</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Symbol">NoSymbol</a><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.ctx" title="(tparams: List[ContextUtil.this.ctx.universe.Symbol], tpe: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.Type">polyType</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.idTC.tvar" title="ContextUtil.this.ctx.universe.TypeSymbol">tvar</a> <a href="#sbt.appmacro;ContextUtil.idTC.x$1" title="(x: ContextUtil.this.ctx.universe.TypeSymbol)List[ContextUtil.this.ctx.universe.TypeSymbol]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.appmacro;ContextUtil.refVar" title="(variable: ContextUtil.this.ctx.universe.TypeSymbol)ContextUtil.this.ctx.universe.Type">refVar</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.idTC.tvar" title="ContextUtil.this.ctx.universe.TypeSymbol">tvar</a><span class="delimiter">)</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="comment">/** A Type that references the given type variable. */</span>
	<span class="keyword">def</span> <a title="(variable: ContextUtil.this.ctx.universe.TypeSymbol)ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.refVar">refVar</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.refVar.variable">variable</a>: <span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> = <a href="#sbt.appmacro;ContextUtil.refVar.variable" title="ContextUtil.this.ctx.universe.TypeSymbol">variable</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">toTypeConstructor</span>
	<span class="comment">/** Constructs a new, synthetic type variable that is a type constructor. For example, in type Y[L[x]], L is such a type variable. */</span>
	<span class="keyword">def</span> <a title="(owner: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTCVariable">newTCVariable</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.newTCVariable.owner">owner</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTCVariable.tc">tc</a> = <a href="#sbt.appmacro;ContextUtil.newTypeVariable" title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol">newTypeVariable</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTCVariable.owner" title="ContextUtil.this.ctx.universe.Symbol">owner</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTCVariable.arg">arg</a> = <a href="#sbt.appmacro;ContextUtil.newTypeVariable" title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol">newTypeVariable</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTCVariable.tc" title="ContextUtil.this.ctx.universe.TypeSymbol">tc</a>, <span title="String(&quot;x&quot;)" class="string">&quot;x&quot;</span><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.newTCVariable.tc" title="ContextUtil.this.ctx.universe.TypeSymbol">tc</a>.<span title="(tpe: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.Symbol">setTypeSignature</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeParams: List[ContextUtil.this.ctx.universe.Symbol], resultType: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.PolyType">PolyType</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTCVariable.arg" title="ContextUtil.this.ctx.universe.TypeSymbol">arg</a> <a href="#sbt.appmacro;ContextUtil.newTCVariable.x$2" title="(x: ContextUtil.this.ctx.universe.TypeSymbol)List[ContextUtil.this.ctx.universe.TypeSymbol]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.appmacro;ContextUtil.emptyTypeBounds" title="=&gt; ContextUtil.this.ctx.universe.TypeBounds">emptyTypeBounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.newTCVariable.tc" title="ContextUtil.this.ctx.universe.TypeSymbol">tc</a>
	<span class="delimiter">}</span>
	<span class="comment">/** &gt;: Nothing &lt;: Any */</span>
	<span class="keyword">def</span> <a title="=&gt; ContextUtil.this.ctx.universe.TypeBounds" id="sbt.appmacro;ContextUtil.emptyTypeBounds">emptyTypeBounds</a>: <span title="ContextUtil.this.ctx.universe.TypeBounds">TypeBounds</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(lo: ContextUtil.this.ctx.universe.Type, hi: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.DefinitionsApi">definitions</a>.<span title="=&gt; ContextUtil.this.ctx.universe.ClassSymbol">NothingClass</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">toType</span>, <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.DefinitionsApi">definitions</a>.<span title="=&gt; ContextUtil.this.ctx.universe.ClassSymbol">AnyClass</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">toType</span><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="(args: List[ContextUtil.this.ctx.universe.Type], result: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.functionType">functionType</a><span class="delimiter">(</span><a title="List[ContextUtil.this.ctx.universe.Type]" id="sbt.appmacro;ContextUtil.functionType.args">args</a>: <span title="List[ContextUtil.this.ctx.universe.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.functionType.result">result</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="scala.tools.nsc.Global" id="sbt.appmacro;ContextUtil.functionType.global">global</a>: <span title="scala.tools.nsc.Global">Global</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.tools.nsc.Global" class="delimiter">[</span><span title="scala.tools.nsc.Global">Global</span><span class="delimiter">]</span>
		<span class="keyword">val</span> <a title="global.Type" id="sbt.appmacro;ContextUtil.functionType.tpe">tpe</a> = <a href="#sbt.appmacro;ContextUtil.functionType.global" title="scala.tools.nsc.Global">global</a>.<span title="global.definitions.type">definitions</span>.<span title="(formals: List[global.Type], restpe: global.Type)global.Type">functionType</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.functionType.args" title="List[ContextUtil.this.ctx.universe.Type]">args</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[global.Type]" class="delimiter">[</span><span title="List[global.Type]">List</span><span class="delimiter">[</span>global.Type<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="#sbt.appmacro;ContextUtil.functionType.result" title="ContextUtil.this.ctx.universe.Type">result</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="global.Type" class="delimiter">[</span>global.<span title="global.Type">Type</span><span class="delimiter">]</span><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.functionType.tpe" title="global.Type">tpe</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Type" class="delimiter">[</span><span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">]</span>
	<span class="delimiter">}</span>

	<span class="comment">/** Create a Tree that references the `val` represented by `vd`. */</span>
	<span class="keyword">def</span> <a title="(vd: ContextUtil.this.ctx.universe.ValDef, pos: ContextUtil.this.ctx.universe.Position)ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.refVal">refVal</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.refVal.vd">vd</a>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span>, <a title="ContextUtil.this.ctx.universe.Position" id="sbt.appmacro;ContextUtil.refVal.pos">pos</a>: <span title="ContextUtil.this.ctx.universe.Position">Position</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Ident" id="sbt.appmacro;ContextUtil.refVal.t">t</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(name: ContextUtil.this.ctx.universe.Name)ContextUtil.this.ctx.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.refVal.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>.<span title="=&gt; ContextUtil.this.ctx.universe.TermName">name</span><span class="delimiter">)</span>
		<span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.refVal.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Tree">tpt</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>, <span title="String(&quot;val type is null: &quot;)" class="string">&quot;val type is null: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.refVal.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, tpt: &quot;)" class="string">&quot;, tpt: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.refVal.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Tree">tpt</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.refVal.t" title="ContextUtil.this.ctx.universe.Ident">t</a>.<span title="(tp: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.Tree">setType</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.refVal.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Tree">tpt</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.refVal.t" title="ContextUtil.this.ctx.universe.Ident">t</a>.<span title="(newpos: ContextUtil.this.ctx.universe.Position)ContextUtil.this.ctx.universe.Tree">setPos</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.refVal.pos" title="ContextUtil.this.ctx.universe.Position">pos</a><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.refVal.t" title="ContextUtil.this.ctx.universe.Ident">t</a>
	<span class="delimiter">}</span>

	<span class="comment">/** Returns the Symbol that references the statically accessible singleton `i`. */</span>
	<span class="keyword">def</span> <a title="[T &lt;: Singleton](i: T)(implicit it: ContextUtil.this.ctx.TypeTag[i.type])ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.singleton">singleton</a><span class="delimiter">[</span><a title=" &lt;: Singleton" id="sbt.appmacro;ContextUtil.singleton;T">T</a> &lt;: AnyRef <span class="keyword">with</span> Singleton<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt.appmacro;ContextUtil.singleton.i">i</a>: <a href="#sbt.appmacro;ContextUtil.singleton;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ContextUtil.this.ctx.TypeTag[i.type]" id="sbt.appmacro;ContextUtil.singleton.it">it</a>: ctx.<span title="ContextUtil.this.ctx.TypeTag[i.type]">TypeTag</span><span class="delimiter">[</span>i.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> =
		<a href="#sbt.appmacro;ContextUtil.singleton.it" title="ContextUtil.this.ctx.TypeTag[i.type]">it</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span> <span title="ContextUtil.this.ctx.universe.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
			<span class="keyword">case</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="(tpe: ContextUtil.this.ctx.universe.SingleType)Option[(ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Symbol)]">SingleType</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.SingleType]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.singleton.sym">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#sbt.appmacro;ContextUtil.singleton.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="=&gt; Boolean">isFreeTerm</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.singleton.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="=&gt; Boolean">isStatic</span> =&gt; <a href="#sbt.appmacro;ContextUtil.singleton.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>
			<span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.singleton.x">x</a> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Instance must be static (was &quot;)" class="string">&quot;Instance must be static (was &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.singleton.x" title="ContextUtil.this.ctx.universe.Type">x</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;).&quot;)" class="string">&quot;).&quot;</span><span class="delimiter">)</span>
		<span class="delimiter">}</span>

	<span class="keyword">def</span> <a title="(t: ContextUtil.this.ctx.universe.Tree, name: String)ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.select">select</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.select.t">t</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="String" id="sbt.appmacro;ContextUtil.select.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(qualifier: ContextUtil.this.ctx.universe.Tree, name: ContextUtil.this.ctx.universe.Name)ContextUtil.this.ctx.universe.Select">Select</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.select.t" title="ContextUtil.this.ctx.universe.Tree">t</a>, <a href="#sbt.appmacro;ContextUtil.ctx" title="(s: String)ContextUtil.this.ctx.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.select.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>

	<span class="comment">/** Returns the symbol for the non-private method named `name` for the class/module `obj`. */</span>
	<span class="keyword">def</span> <a title="(obj: ContextUtil.this.ctx.universe.Symbol, name: String)ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.method">method</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.method.obj">obj</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span>, <a title="String" id="sbt.appmacro;ContextUtil.method.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> = <span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="scala.tools.nsc.Global" id="sbt.appmacro;ContextUtil.method.global">global</a>: <span title="scala.tools.nsc.Global">Global</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.tools.nsc.Global" class="delimiter">[</span><span title="scala.tools.nsc.Global">Global</span><span class="delimiter">]</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.method.ts">ts</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> = <a href="#sbt.appmacro;ContextUtil.method.obj" title="ContextUtil.this.ctx.universe.Symbol">obj</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">typeSignature</span>
		<span class="keyword">val</span> <a title="global.Symbol" id="sbt.appmacro;ContextUtil.method.m">m</a>: global.<span title="global.Symbol">Symbol</span> = <a href="#sbt.appmacro;ContextUtil.method.ts" title="ContextUtil.this.ctx.universe.Type">ts</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="global.Type" class="delimiter">[</span>global.<span title="global.Type">Type</span><span class="delimiter">]</span>.<span title="(name: global.Name)global.Symbol">nonPrivateMember</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.method.global" title="scala.tools.nsc.Global">global</a>.<span title="(s: String)global.TermName">newTermName</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.method.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.method.m" title="global.Symbol">m</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Symbol" class="delimiter">[</span><span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">]</span>
	<span class="delimiter">}</span>

	<span class="comment">/** Returns a Type representing the type constructor tcp.&lt;name&gt;.  For example, given
	*  `object Demo { type M[x] = List[x] }`, the call `extractTC(Demo, &quot;M&quot;)` will return a type representing
	* the type constructor `[x] List[x]`.
	**/</span>
	<span class="keyword">def</span> <a title="(tcp: Singleton, name: String)(implicit it: ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type])ContextUtil.this.ctx.Type" id="sbt.appmacro;ContextUtil.extractTC">extractTC</a><span class="delimiter">(</span><a title="ContextUtil extends AnyRef with Singleton" id="sbt.appmacro;ContextUtil.extractTC.tcp">tcp</a>: <a href="#sbt.appmacro;ContextUtil;<refinement>" title="ContextUtil extends AnyRef with Singleton">AnyRef</a> <span class="keyword">with</span> Singleton, <a title="String" id="sbt.appmacro;ContextUtil.extractTC.name">name</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type]" id="sbt.appmacro;ContextUtil.extractTC.it">it</a>: ctx.<span title="ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type]">TypeTag</span><span class="delimiter">[</span>tcp.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: ctx.<span title="ContextUtil.this.ctx.Type">Type</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="scala.tools.nsc.Global" id="sbt.appmacro;ContextUtil.extractTC.global">global</a>: <span title="scala.tools.nsc.Global">Global</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.tools.nsc.Global" class="delimiter">[</span><span title="scala.tools.nsc.Global">Global</span><span class="delimiter">]</span>
		<span class="keyword">val</span> <a title="global.Type" id="sbt.appmacro;ContextUtil.extractTC.itTpe">itTpe</a> = <a href="#sbt.appmacro;ContextUtil.extractTC.it" title="ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type]">it</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="global.Type" class="delimiter">[</span>global.<span title="global.Type">Type</span><span class="delimiter">]</span>
		<span class="keyword">val</span> <a title="global.Symbol" id="sbt.appmacro;ContextUtil.extractTC.m">m</a> = <a href="#sbt.appmacro;ContextUtil.extractTC.itTpe" title="global.Type">itTpe</a>.<span title="(name: global.Name)global.Symbol">nonPrivateMember</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.extractTC.global" title="scala.tools.nsc.Global">global</a>.<span title="(s: String)global.TypeName">newTypeName</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.extractTC.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.extractTC.tc">tc</a> = <a href="#sbt.appmacro;ContextUtil.extractTC.itTpe" title="global.Type">itTpe</a>.<span title="(sym: global.Symbol)global.Type">memberInfo</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.extractTC.m" title="global.Symbol">m</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Type" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">]</span>
		<span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Type">NoType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a>.<span title="=&gt; Boolean">takesTypeArgs</span>, <span title="String(&quot;Invalid type constructor: &quot;)" class="string">&quot;Invalid type constructor: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a><span class="delimiter">)</span>
		<a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a>
	<span class="delimiter">}</span>

	<span class="comment">/** Substitutes wrappers in tree `t` with the result of `subWrapper`.
	* A wrapper is a Tree of the form `f[T](v)` for which isWrapper(&lt;Tree of f&gt;, &lt;Underlying Type&gt;, &lt;qual&gt;.target) returns true.
	* Typically, `f` is a `Select` or `Ident`.
	* The wrapper is replaced with the result of `subWrapper(&lt;Type of T&gt;, &lt;Tree of v&gt;)` */</span>
	<span class="keyword">def</span> <a title="(t: ContextUtil.this.ctx.universe.Tree, subWrapper: (String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; sbt.appmacro.Converted[ContextUtil.this.ctx.type])ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers">transformWrappers</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers.t">t</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="(String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; sbt.appmacro.Converted[ContextUtil.this.ctx.type]" id="sbt.appmacro;ContextUtil.transformWrappers.subWrapper">subWrapper</a>: <span class="delimiter">(</span>String, Type, Tree<span class="delimiter">)</span> =&gt; Converted<span class="delimiter">[</span>ctx.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
	<span class="delimiter">{</span>
		<span class="comment">// the main tree transformer that replaces calls to InputWrapper.wrap(x) with</span>
		<span class="comment">//  plain Idents that reference the actual input value</span>
		<span class="keyword">object</span> <a title="appTransformer.type" id="sbt.appmacro;ContextUtil.transformWrappers.appTransformer">appTransformer</a> <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer" title="appTransformer.type" class="keyword">extends</a> <a href="#sbt.appmacro;ContextUtil.ctx" title="ContextUtil.this.ctx.universe.Transformer">Transformer</a>
		<span class="delimiter">{</span>
			<span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform">transform</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree">tree</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
				<a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a> <span title="ContextUtil.this.ctx.universe.Tree" class="keyword">match</span>
				<span class="delimiter">{</span>
					<span class="keyword">case</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="(apply: ContextUtil.this.ctx.universe.Apply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">ApplyTree</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Apply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeApply: ContextUtil.this.ctx.universe.TypeApply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">TypeApply</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.TypeApply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(select: ContextUtil.this.ctx.universe.Select)Option[(ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Name)]">Select</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Select]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.nme">nme</a><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.targ">targ</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.qual">qual</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro;ContextUtil.transformWrappers.subWrapper" title="(v1: String, v2: ContextUtil.this.ctx.universe.Type, v3: ContextUtil.this.ctx.universe.Tree)sbt.appmacro.Converted[ContextUtil.this.ctx.type]">subWrapper</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.nme" title="ContextUtil.this.ctx.universe.Name">nme</a>.<span title="=&gt; String">decoded</span>, <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.targ" title="ContextUtil.this.ctx.universe.Tree">targ</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>, <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.qual" title="ContextUtil.this.ctx.universe.Tree">qual</a><span class="delimiter">)</span> <span title="ContextUtil.this.ctx.universe.Tree" class="keyword">match</span> <span class="delimiter">{</span>
						<span class="keyword">case</span> Converted.Success<span class="delimiter">(</span><a title="ContextUtil.this.ctx.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.t">t</a>, <a title="ContextUtil.this.ctx.Tree =&gt; ContextUtil.this.ctx.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.finalTx">finalTx</a><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.finalTx" title="(v1: ContextUtil.this.ctx.Tree)ContextUtil.this.ctx.Tree">finalTx</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.t" title="ContextUtil.this.ctx.Tree">t</a><span class="delimiter">)</span>
						<span class="keyword">case</span> Converted.Failure<span class="delimiter">(</span><a title="ContextUtil.this.ctx.Position" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.p">p</a>,<a title="String" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.m">m</a><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(pos: ContextUtil.this.ctx.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.p" title="ContextUtil.this.ctx.Position">p</a>, <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.m" title="String">m</a><span class="delimiter">)</span>
						<span class="keyword">case</span> _: Converted.<a href="Convert.scala.html#sbt.appmacro.Converted;NotApplicable" title="sbt.appmacro.Converted.NotApplicable[_]">NotApplicable</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <span class="keyword">super</span>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree">transform</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
					<span class="delimiter">}</span>
					<span class="keyword">case</span> _ =&gt; <span class="keyword">super</span>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree">transform</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
				<span class="delimiter">}</span>
		<span class="delimiter">}</span>

		<a href="#sbt.appmacro;ContextUtil.transformWrappers.appTransformer" title="appTransformer.type">appTransformer</a>.<a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform" title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree">transform</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers.t" title="ContextUtil.this.ctx.universe.Tree">t</a><span class="delimiter">)</span>
	<span class="delimiter">}</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
