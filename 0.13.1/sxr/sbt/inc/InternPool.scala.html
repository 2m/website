<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/inc/InternPool.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> inc


<span class="keyword">import</span> sbinary._
<span class="keyword">import</span> <span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>._
<span class="keyword">import</span> xsbti.api.Lazy
<span class="keyword">import</span> xsbti.SafeLazy


<span class="comment">/**
 * A simple intern pool for sharing references to a unique instance of some immutable type.
 * The primary purpose of this class is to improve performance of analysis serialization/deserialization.
 *
 * Pooling occurs on serialization: all equal objects are serialized as a 32-bit integer index of a single representative. 
 * This allows us to benefit from pooling without changing all the object allocation sites.
 *
 * On deserialization that single representative is used where previously there might have been multiple equal instances.
 * Thus, round-tripping an analysis may yield a smaller in-memory object graph.
 *
 * Note that the set of pooled items must be known before serialization begins. We can't build it up on-the-fly as
 * we serialize: We must serialize the entire pool before serializing anything that uses it, as we'll need to read the
 * entire pool in first when deserializing. The InternPool is immutable to enforce this.
 */</span>
<span class="keyword">class</span> <a title="class InternPool[T &lt;: AnyRef] extends AnyRef with Serializable" id="sbt.inc;InternPool">InternPool</a><span class="delimiter">[</span><a title=" &lt;: AnyRef" id="sbt.inc;InternPool;T">T</a> &lt;: AnyRef<span class="delimiter">]</span><a href="#sbt.inc;InternPool" title="sbt.inc.InternPool[T]" class="delimiter">(</a><a title="Array[T]" id="sbt.inc;InternPool.itemsArray">itemsArray</a>: <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Serializable">Serializable</span> <span class="delimiter">{</span>
	<span class="keyword">def</span> <a title="(item: T)Int" id="sbt.inc;InternPool.toIdx">toIdx</a><span class="delimiter">(</span><a title="T" id="sbt.inc;InternPool.toIdx.item">item</a>: <a href="#sbt.inc;InternPool;T" title="T">T</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#sbt.inc;InternPool.itemToIdx" title="scala.collection.immutable.Map[T,Int]">itemToIdx</a>.<span title="(key: T)Option[Int]">get</span><span class="delimiter">(</span><a href="#sbt.inc;InternPool.toIdx.item" title="T">item</a><span class="delimiter">)</span> <span title="Int" class="keyword">match</span> <span class="delimiter">{</span>
		<span class="keyword">case</span> <span title="None.type">None</span> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;No such item in intern pool: %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#sbt.inc;InternPool.toIdx.item" title="T">item</a>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span>
		<span class="keyword">case</span> Some<span class="delimiter">(</span><a title="Int" id="sbt.inc;InternPool.toIdx.x">x</a><span class="delimiter">)</span> =&gt; <a href="#sbt.inc;InternPool.toIdx.x" title="Int">x</a>
	<span class="delimiter">}</span>

	<span class="keyword">def</span> <a title="(idx: Int)T" id="sbt.inc;InternPool.toItem">toItem</a><span class="delimiter">(</span><a title="Int" id="sbt.inc;InternPool.toItem.idx">idx</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#sbt.inc;InternPool;T" title="T">T</a> = <span title="T" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.inc;InternPool.toItem.idx" title="Int">idx</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.inc;InternPool.toItem.idx" title="Int">idx</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#sbt.inc;InternPool.items" title="Array[T]">items</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#sbt.inc;InternPool.items" title="(i: Int)T">items</a><span class="delimiter">(</span><a href="#sbt.inc;InternPool.toItem.idx" title="Int">idx</a><span class="delimiter">)</span> <span class="keyword">else</span> sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;No such index in intern pool: %d&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#sbt.inc;InternPool.toItem.idx" title="Int">idx</a><span class="delimiter">)</span><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="=&gt; Array[T]" id="sbt.inc;InternPool.allItems">allItems</a>: <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.inc;InternPool.items" title="Array[T]">items</a>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="Array[T]" id="sbt.inc;InternPool.items">items</a> = <a href="#sbt.inc;InternPool.itemsArray" title="Array[T]">itemsArray</a>
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[T,Int]" id="sbt.inc;InternPool.itemToIdx">itemToIdx</a> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[T,Int]" class="delimiter">[</span><a href="#sbt.inc;InternPool;T" title="T">T</a>, <span title="Int">Int</span><span class="delimiter">]</span> <span title="(xs: scala.collection.GenTraversableOnce[(T, Int)])scala.collection.immutable.Map[T,Int]">++</span> <a href="#sbt.inc;InternPool.itemsArray" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">itemsArray</a>.<span title="(xs: Array[(T, Int)])scala.collection.mutable.ArrayOps[(T, Int)]">zipWithIndex</span>
<span class="delimiter">}</span>


<span class="comment">/**
 * Serialization formats that use an InternPool.
 *
 * fullFormat is the format to use for T when serializing the pool itself.
 */</span>
<span class="keyword">class</span> <a title="class InternPoolFormats[T &lt;: AnyRef] extends AnyRef" id="sbt.inc;InternPoolFormats">InternPoolFormats</a><span class="delimiter">[</span><a title=" &lt;: AnyRef" id="sbt.inc;InternPoolFormats;T">T</a> &lt;: AnyRef<span class="delimiter">]</span><a href="#sbt.inc;InternPoolFormats" title="sbt.inc.InternPoolFormats[T]" class="delimiter">(</a><a title="sbinary.Format[T]" id="sbt.inc;InternPoolFormats.fullFormat">fullFormat</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Manifest[T]" id="sbt.inc;InternPoolFormats.mf">mf</a>: <span title="Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
	<span class="keyword">var</span> <a title="Option[sbt.inc.InternPool[T]]" id="sbt.inc;InternPoolFormats.pool_=">pool</a>: <span title="Option[sbt.inc.InternPool[T]]">Option</span><span class="delimiter">[</span>InternPool<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="None.type">None</span>

	<span class="comment">/**
	 * Create the intern pool immediately before writing it/after reading it, so it can be used for subsequent writes/reads.
	 */</span>
	<span class="keyword">def</span> <a title="(items: Array[T])sbt.inc.InternPool[T]" id="sbt.inc;InternPoolFormats.initPool">initPool</a><span class="delimiter">(</span><a title="Array[T]" id="sbt.inc;InternPoolFormats.initPool.items">items</a>: <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.inc;InternPool" title="sbt.inc.InternPool[T]">InternPool</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
		<a href="#sbt.inc;InternPoolFormats.pool_=" title="(x$1: Option[sbt.inc.InternPool[T]])Unit">pool</a> = <span title="(x: sbt.inc.InternPool[T])Some[sbt.inc.InternPool[T]]">Some</span><span class="delimiter">(</span><span title="sbt.inc.InternPool[T]" class="keyword">new</span> <a href="#sbt.inc;InternPool" title="sbt.inc.InternPool[T]">InternPool</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.initPool.items" title="Array[T]">items</a><span class="delimiter">)</span><span class="delimiter">)</span>
		<a href="#sbt.inc;InternPoolFormats.pool_=" title="=&gt; Option[sbt.inc.InternPool[T]]">pool</a>.<span title="=&gt; sbt.inc.InternPool[T]">get</span>
	<span class="delimiter">}</span>

	<span class="comment">/** Format for writing a T as a pool reference. */</span>
	<span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbinary.Format[T]" id="sbt.inc;InternPoolFormats.itemFormat">itemFormat</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="[S, T](to: S =&gt; T, from: T =&gt; S)(implicit bin: sbinary.Format[T])sbinary.Format[S]">wrap</span><span title="(to: T =&gt; Int, from: Int =&gt; T)(implicit bin: sbinary.Format[Int])sbinary.Format[T]" class="delimiter">[</span><a href="#sbt.inc;InternPoolFormats;T" title="T">T</a>, <span title="Int">Int</span><span class="delimiter">]</span><span title="sbinary.DefaultProtocol.IntFormat.type" class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.toIdx" title="(item: T)Int">toIdx</a>, <a href="#sbt.inc;InternPoolFormats.toItem" title="(idx: Int)T">toItem</a><span class="delimiter">)</span>

	<span class="comment">/** Format for writing a T as a lazily-resolved pool reference. */</span>
	<span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbinary.Format[xsbti.api.Lazy[T]]" id="sbt.inc;InternPoolFormats.lazyItemFormat">lazyItemFormat</a>: <span title="sbinary.Format[xsbti.api.Lazy[T]]">Format</span><span class="delimiter">[</span>Lazy<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="[S, T](to: S =&gt; T, from: T =&gt; S)(implicit bin: sbinary.Format[T])sbinary.Format[S]">wrap</span><span title="(to: xsbti.api.Lazy[T] =&gt; Int, from: Int =&gt; xsbti.api.Lazy[T])(implicit bin: sbinary.Format[Int])sbinary.Format[xsbti.api.Lazy[T]]" class="delimiter">[</span><a href="../../xsbti/api/Lazy.java.html#xsbti.api;Lazy" title="xsbti.api.Lazy[T]">Lazy</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span title="Int">Int</span><span class="delimiter">]</span><span title="sbinary.DefaultProtocol.IntFormat.type" class="delimiter">(</span><a title="xsbti.api.Lazy[T]" id="sbt.inc;InternPoolFormats.lazyItemFormat.$anonfun.x">x</a> =&gt; <a href="#sbt.inc;InternPoolFormats.toIdx" title="(item: T)Int">toIdx</a><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.lazyItemFormat.$anonfun.x" title="xsbti.api.Lazy[T]">x</a>.<a href="../../xsbti/api/Lazy.java.html#xsbti.api;Lazy.get" title="()T">get</a><span class="delimiter">)</span>, <a title="Int" id="sbt.inc;InternPoolFormats.lazyItemFormat.$anonfun.idx">idx</a> =&gt; <a href="../../xsbti/SafeLazy.scala.html#xsbti.SafeLazy" title="xsbti.SafeLazy.type">SafeLazy</a>.<a href="../../xsbti/SafeLazy.scala.html#xsbti.SafeLazy.apply(8c88397f5b)" title="[T &lt;: AnyRef](eval: =&gt; T)xsbti.api.Lazy[T]">apply</a><span title="(eval: =&gt; T)xsbti.api.Lazy[T]" class="delimiter">[</span><a href="#sbt.inc;InternPoolFormats;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.toItem" title="(idx: Int)T">toItem</a><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.lazyItemFormat.$anonfun.idx" title="Int">idx</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

	<span class="comment">/** Format for writing an array of T as a lazily-resolved pool reference. */</span>
	<span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbinary.Format[xsbti.api.Lazy[Array[T]]]" id="sbt.inc;InternPoolFormats.lazyItemsFormat">lazyItemsFormat</a>: <span title="sbinary.Format[xsbti.api.Lazy[Array[T]]]">Format</span><span class="delimiter">[</span>Lazy<span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="[S, T](to: S =&gt; T, from: T =&gt; S)(implicit bin: sbinary.Format[T])sbinary.Format[S]">wrap</span><span title="(to: xsbti.api.Lazy[Array[T]] =&gt; Array[Int], from: Array[Int] =&gt; xsbti.api.Lazy[Array[T]])(implicit bin: sbinary.Format[Array[Int]])sbinary.Format[xsbti.api.Lazy[Array[T]]]" class="delimiter">[</span><a href="../../xsbti/api/Lazy.java.html#xsbti.api;Lazy" title="xsbti.api.Lazy[Array[T]]">Lazy</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <span title="Array[Int]">Array</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">]</span><span title="(implicit fmt: sbinary.Format[Int], implicit mf: scala.reflect.Manifest[Int])sbinary.Format[Array[Int]]" class="delimiter">(</span>
		<a title="xsbti.api.Lazy[Array[T]]" id="sbt.inc;InternPoolFormats.lazyItemsFormat.$anonfun.x">x</a> =&gt; <a href="#sbt.inc;InternPoolFormats.lazyItemsFormat.$anonfun.x" title="xsbti.api.Lazy[Array[T]]">x</a>.<a href="../../xsbti/api/Lazy.java.html#xsbti.api;Lazy.get" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">get</a> <span title="(f: T =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[Array[T],Int,Array[Int]])Array[Int]">map</span> <a href="#sbt.inc;InternPoolFormats.toIdx" title="(item: T)Int">toIdx</a>,
		<a title="Array[Int]" id="sbt.inc;InternPoolFormats.lazyItemsFormat.$anonfun.idxes">idxes</a> =&gt; <a href="../../xsbti/SafeLazy.scala.html#xsbti.SafeLazy" title="xsbti.SafeLazy.type">SafeLazy</a>.<a href="../../xsbti/SafeLazy.scala.html#xsbti.SafeLazy.apply(8c88397f5b)" title="[T &lt;: AnyRef](eval: =&gt; T)xsbti.api.Lazy[T]">apply</a><span title="(eval: =&gt; Array[T])xsbti.api.Lazy[Array[T]]" class="delimiter">[</span><span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.lazyItemsFormat.$anonfun.idxes" title="implicit scala.Predef.intArrayOps : (xs: Array[Int])scala.collection.mutable.ArrayOps[Int]">idxes</a> <a href="#sbt.inc;InternPoolFormats.mf" title="(f: Int =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Array[Int],T,Array[T]])Array[T]">map</a> <a href="#sbt.inc;InternPoolFormats.toItem" title="(idx: Int)T">toItem</a><span class="delimiter">)</span>
	<span class="delimiter">)</span>

	<span class="comment">/** Format for writing the pool itself. */</span>
	<span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbinary.Format[sbt.inc.InternPool[T]]" id="sbt.inc;InternPoolFormats.poolFormat">poolFormat</a>: <span title="sbinary.Format[sbt.inc.InternPool[T]]">Format</span><span class="delimiter">[</span>InternPool<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="[S, T](to: S =&gt; T, from: T =&gt; S)(implicit bin: sbinary.Format[T])sbinary.Format[S]">wrap</span><span title="(to: sbt.inc.InternPool[T] =&gt; Array[T], from: Array[T] =&gt; sbt.inc.InternPool[T])(implicit bin: sbinary.Format[Array[T]])sbinary.Format[sbt.inc.InternPool[T]]" class="delimiter">[</span><a href="#sbt.inc;InternPool" title="sbt.inc.InternPool[T]">InternPool</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.poolFormat.$anonfun.x$1" title="sbt.inc.InternPool[T]">_</a>.<a href="#sbt.inc;InternPool.allItems" title="=&gt; Array[T]">allItems</a>, <a href="#sbt.inc;InternPoolFormats.initPool" title="(items: Array[T])sbt.inc.InternPool[T]">initPool</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(implicit fmt: sbinary.Format[T], implicit mf: scala.reflect.Manifest[T])sbinary.Format[Array[T]]">arrayFormat</span><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.fullFormat" title="sbinary.Format[T]">fullFormat</a>, <a href="#sbt.inc;InternPoolFormats.mf" title="Manifest[T]">mf</a><span class="delimiter">)</span><span class="delimiter">)</span>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(item: T)Int" id="sbt.inc;InternPoolFormats.toIdx">toIdx</a><span class="delimiter">(</span><a title="T" id="sbt.inc;InternPoolFormats.toIdx.item">item</a>: <a href="#sbt.inc;InternPoolFormats;T" title="T">T</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
		<a href="#sbt.inc;InternPoolFormats.pool_=" title="=&gt; Option[sbt.inc.InternPool[T]]">pool</a>.<span title="=&gt; sbt.inc.InternPool[T]">get</span>.<a href="#sbt.inc;InternPool.toIdx" title="(item: T)Int">toIdx</a><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.toIdx.item" title="T">item</a><span class="delimiter">)</span>
	<span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
		<span class="keyword">case</span> <a title="NoSuchElementException" id="sbt.inc;InternPoolFormats.toIdx.e">e</a>: <span title="NoSuchElementException">NoSuchElementException</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)RuntimeException" class="keyword">new</span> <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="String(&quot;Intern pool not available for &quot;)" class="string">&quot;Intern pool not available for &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.inc;InternPoolFormats.mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span>.<span title="()String">getName</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(idx: Int)T" id="sbt.inc;InternPoolFormats.toItem">toItem</a><span class="delimiter">(</span><a title="Int" id="sbt.inc;InternPoolFormats.toItem.idx">idx</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#sbt.inc;InternPoolFormats;T" title="T">T</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
		<a href="#sbt.inc;InternPoolFormats.pool_=" title="=&gt; Option[sbt.inc.InternPool[T]]">pool</a>.<span title="=&gt; sbt.inc.InternPool[T]">get</span>.<a href="#sbt.inc;InternPool.toItem" title="(idx: Int)T">toItem</a><span class="delimiter">(</span><a href="#sbt.inc;InternPoolFormats.toItem.idx" title="Int">idx</a><span class="delimiter">)</span>
	<span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
		<span class="keyword">case</span> <a title="NoSuchElementException" id="sbt.inc;InternPoolFormats.toItem.e">e</a>: <span title="NoSuchElementException">NoSuchElementException</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)RuntimeException" class="keyword">new</span> <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="String(&quot;Intern pool not available for &quot;)" class="string">&quot;Intern pool not available for &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.inc;InternPoolFormats.mf" title="Manifest[T]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span>.<span title="()String">getName</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
